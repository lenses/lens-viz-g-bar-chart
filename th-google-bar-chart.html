<link rel="import" href="../polymer/polymer.html"> 
<link rel="import" href="../th-d3-chart/th-d3-chart.html"> 
<link rel="import" href="../google-chart/google-chart.html">
<link rel="import" href="../th-data-utility/th-data-utility.html">
<link rel="import" href="../th-u-data-selector/th-u-data-selector.html">

<!--
A Thelma component providing solution to no problem in particular.

##### Example

    <th-google-bar-chart></th-google-bar-chart>

@element th-google-bar-chart
@blurb Element providing solution to no problem in particular.
@status alpha
@homepage http://nishacodes.github.io/th-google-bar-chart
-->

<polymer-element name="th-google-bar-chart" extends="th-d3-chart"  attributes="input chartData output selectedLabel selectedValues orientation legend showOptions labelValueSelection chartTitle chartSubtitle gridlines yAxisMin yAxisMax fontSize hAxisTitle vAxisTitle backgroundColor textColor gridlinesColor">
  <template>
    <core-style ref="theme"></core-style>
    <link rel="stylesheet" href="th-google-bar-chart.css">
    <th-data-utility id="utility"></th-data-utility>
    <th-u-data-selector id="data_selector" input="{{chartData}}" selections="{{labelValueSelection}}" style="display: {{showOptions | displayFilter}}; height: 10%;"></th-u-data-selector>
    <google-chart id="googleChart" on-google-chart-render="{{chartReady}}" style="width:100%; height: {{showOptions | heightFilter}};"
          type='column'
          options= "{{options}}"
          data="{{_data}}">
    </google-chart>
  </template>
  <script>
// TODO 
// - accept array of arrays as input, and get attributes accordingly
// - integrate data utility to convert strings
// - integrate data utility to detect numerical column


    Polymer({
      // selectedLabel: "Year",
      // selectedValues: ["Sales","Profit"],
      // chartData: [
      //   {"Year": "2014", "Sales": 100, "Profit": 50},
      //   {"Year": "2015", "Sales": 50, "Profit": 40},
      //   {"Year": "2016", "Sales": 300, "Profit": 200}
      // ],
      // chartData: [
      //   ["Year", "Sales","Profit"],
      //   ["2014", 100, 50],
      //   ["2015", 50, 40],
      //   ["2016", 300, 200]
      // ],
      orientation: "horizontal",
      labelValueSelection: null,
      legend: true,
      showOptions: true,
      observe: {
        legend: "updateOptions",
        orientation: "updateOptions",
        gridlines: "updateOptions",
        gridlinesColor: "updateOptions",
        backgroundColor: "updateOptions",
        textColor: "updateOptions",
        chartTitle: "updateOptions",
        hAxisTitle: "updateOptions",
        vAxisTitle: "updateOptions",
        fontSize: "updateOptions",
        yAxisMin: "updateOptions",
        yAxisMax: "updateOptions"
      },
      ready : function() {
        var self = this;
        this.dataSelector = this.$.data_selector;

        // Listen for theme changes
        document.addEventListener('th-theme-changed', function(e) {
          this.getColors();
          this.updateOptions();
        }.bind(this));

        //this._configureOptions();
        this.reformatData();
        
        this.dataSelector.addEventListener('th-data-selection-changed', function() {
          this.labelValueSelection = this.dataSelector.selections;
          //set published selections for saving the component
          this.selectedLabel = this.labelValueSelection[0];
          this.selectedValues = this.labelValueSelection[1];
          this.reformatData();
        }.bind(this));
      },
      selectedLabelChanged: function() {
        //if selectedLabel changed from outside, set the internal data_selector    
        this.dataSelector.selections[0] = this.selectedLabel;
      },
      selectedValuesChanged: function() {
        //if selectedValue changed from outside, set the internal data_selector
        this.dataSelector.selections[1] = this.selectedValues;
      },
      inputChanged: function () {
        var self = this;
        self.chartData = self.input;
        self.reformatData();
        self.configureOptions();
      },
      /**
       * 'reformatData' converts chartData into the correct data structure for the map
       */
      reformatData: function(){
        var self = this; 


        if(!self.labelValueSelection || !self.labelValueSelection[0] || !self.labelValueSelection[1]) {
          return;
        }
        var firstRow = self.labelValueSelection[1].map(function(item){ return item;}) ;
        
        self._data = self.chartData.map(function(item){
          var row = [];
          row.push(item[self.labelValueSelection[0]]);
          for(var i=0; i<self.labelValueSelection[1].length; i++){
            var unformattedValue = self.$.utility.unformatString(item[self.labelValueSelection[1][i]]);
            row.push(unformattedValue);
          }
          return row;
        });

        firstRow.unshift(self.labelValueSelection[0]);
        self._data.unshift(firstRow);
      },
      /**
       * Overrides th-d3-chart function. called by observers when input or chartData changes
       * @return {[type]} [description]
       */
      updateData: function() {
        this.reformatData();
      },
      updateOptions: function(){
        this.configureOptions();
        this.$.googleChart.drawChart();
      },
      /**
       * 'configureOptions' sets the appropriate options properties for the map, given the attribute values
       */
      configureOptions: function(){
        var self = this,
            colors =  self.getColors();

        var fgColor = self.textColor || colors.theme.foreground1 || "black";
        var bgColor = self.backgroundColor || colors.theme.background || "none";

        // Define chart options 
        self.options = {
          title: self.chartTitle,
          titleTextStyle: { color: fgColor, fontName: colors.theme.font, fontSize: self.fontSize*1.5},
          fontSize: self.fontSize,
          orientation: self.orientation,
          colors: colors.accents,
          chartArea:{left:'auto',top:'auto', width: '80%', height:'80%'},
          backgroundColor: bgColor,
          animation: {duration: "500"},
          legend: { 
            position: "bottom",
            alignment: "center",
            textStyle: { 
              color: fgColor, 
              fontName: colors.theme.font, 
              fontSize: '0.85em',
              stroke: 'none',
              strokeWidth: '0'            
            } 
          },
          vAxis: {
            title: self.vAxisTitle,
            titleTextStyle: { color: fgColor, fontName: colors.theme.font, fontSize: self.fontSize*1.25},
            baselineColor: fgColor,
            format: "#,###.##", //TODO: add more options here and figure out how to format numbers in tooltips
            textStyle:{ color: fgColor, fontName: colors.theme.font, fontSize: '0.85em'},
            minValue: self.orientation === "horizontal" ? self.yAxisMin : "automatic",
            maxValue: self.orientation === "horizontal" ? self.yAxisMax : "automatic",
            gridlines: {
              count: self.gridlines,
              color: self.gridlinesColors || fgColor
            }
          },
          hAxis: {
            title: self.hAxisTitle,
            titleTextStyle: { color: fgColor, fontName: colors.theme.font, fontSize: self.fontSize*1.25},
            baselineColor: fgColor,
            format: "#,###.##", //TODO: add more options here and figure out how to format numbers in tooltips
            textStyle:{ color: fgColor, fontName: colors.theme.font, fontSize: '0.85em'},
            minValue: self.orientation === "vertical" ? self.yAxisMin : "automatic",
            maxValue: self.orientation === "vertical" ? self.yAxisMax : "automatic",
            gridlines: {
              count: self.gridlines,
              color: self.gridlinesColors || fgColor
            }
          }
        };

        if (!self.legend) { self.options.legend = 'none';}
        
      },
      reset: function(){
        // Reset is a method inherited from the 'th-animated' Thelma component.
        // You can include code that takes the component back to the pre-animated state.

      },
      getColors: function(){
        colors = {};
        colors.theme = window.CoreStyle.g.theme;
        colors.accents = [];

        for (var color in colors.theme){
          if(/^accent/.test(color)){
            colors.accents.push(colors.theme[color]);
          }
        }

        colors.count = colors.accents.length;

        return colors;
      },
      resize: function() {
        this.$.googleChart.drawChart();
      },
      displayFilter: function(value){
        return value ? "inline-block" : "none";
      },
      heightFilter: function(value){
        return value ? "90%" : "100%";
      },
      getMetaData: function(){
        return {
          "name": "th-google-bar-chart",
          "description": "Multi Bar Chart by Google",
          "category":"chart",
          "version": "0.0.1",
          "inputAttr": {
            "chartTitle":{"friendly":"Title", "type":"string", "default":""},
            "vAxisTitle":{"friendly":"Vertical Axis Title", "type":"string", "default":""},
            "hAxisTitle":{"friendly":"Horizontal Axis Title", "type":"string", "default":""},
            "orientation": {"friendly":"Orientation", "type": "dropdown", "default": "horizontal", "values":["horizontal", "vertical"]},
            "fontSize":{"friendly":"Font Size", "type":"int", "default":""},
            "textColor":{"friendly":"Text Color", "type":"color", "default":""},
            "backgroundColor":{"friendly":"Background Color", "type":"color", "default":""},
            "gridlinesColor":{"friendly":"Gridlines Color", "type":"color", "default":""},
            "gridlines":{"friendly":"Number of Gridlines", "type":"int", "default":"5"},
            "yAxisMin":{"friendly":"Y Axis Min", "type":"int", "default":""},
            "yAxisMax":{"friendly":"Y Axis Max", "type":"int", "default":""},
            "legend":{"friendly":"Show Legend?", "type":"boolean", "default": true}
          }
        }
      }

    });
  </script>
</polymer-element>